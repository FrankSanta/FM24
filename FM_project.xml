<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.6//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_6.dtd'>
<nta>
	<declaration>clock globalTime;
const int T_fr = 5;       // assistance time of a first responder
const int T_zr = 7;       // assistance time of a zero responder
const int Nv = 3;         // drone visibility

// Entity type
const int SURVIVOR = 0;
const int VICTIM = 1;
const int FIRST_RESPONDER = 2;
const int DRONE = 3;

// Tile type in the map
const int FREE = 0;
const int FIRE = 1;
const int EXIT = 2;

/*#################### Declaration ####################
THIS PORTION IS AUTOGENERATED */

const int N = 20;   // map rows
const int M = 20;   // map columns
typedef int[-1,N] coordx_t;
typedef int[-1,M] coordy_t;

// Entity amounts
const int SURVIVORS_QTY = 5;
const int VICTIMS_QTY = 5;
const int FIRST_RESPONDERS_QTY = 5;
const int DRONES_QTY = 4;
int[0,5] entities[4] = {SURVIVORS_QTY, VICTIMS_QTY, FIRST_RESPONDERS_QTY, DRONES_QTY};

// IDs
typedef int[0,SURVIVORS_QTY-1] id_s_t;
typedef int[0,VICTIMS_QTY-1] id_v_t;
typedef int[0,FIRST_RESPONDERS_QTY-1] id_f_t;
typedef int[0,DRONES_QTY-1] id_d_t;

// Busy statuses
bool survivors_busy[SURVIVORS_QTY];
bool victims_busy[VICTIMS_QTY];
bool responders_busy[FIRST_RESPONDERS_QTY];

typedef struct {
    coordx_t x;
    coordy_t y;
} pos_t;
const pos_t pos_out_of_map = {N,M};

typedef struct {
    int[-1,1] x;
    int[-1,1] y;
} pos_delta_t;

typedef struct {
    coordx_t min_x;
    coordy_t min_y;
    coordx_t max_x;
    coordy_t max_y;
} bounds_t;

// Positions for survivors, victims and first responders
pos_t survivors[SURVIVORS_QTY] = {{1,13}, {14,5}, {1,10}, {10,1}, {16,7}};
pos_t victims[VICTIMS_QTY] = {{4,6}, {6,15}, {7,10}, {19,5}, {14,7}};
pos_t responders[FIRST_RESPONDERS_QTY] = {{2,5}, {18,0}, {15,15}, {3,5}, {3,3}};

// Positions and area bounds for drones
pos_t drones[DRONES_QTY] = {{1,1}, {1,10}, {10,1}, {10,10}};
bounds_t bounds[DRONES_QTY] = {{1 , 1, 9, 9}, {10, 10, 19, 19}, {1, 10, 9, 19}, {10, 1, 19, 9}};

int[0,2] map[N][M] = {
  {0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
  {0,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0},
  {0,0,0,1,1,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0},
  {0,0,1,1,1,0,0,1,1,1,0,1,1,0,0,0,0,0,0,0},
  {0,0,1,1,1,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0},
  {0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0},
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0},
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0},
  {2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2},
  {2,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,2},
  {0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0},
  {1,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0},
  {1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
  {1,1,1,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0},
  {0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0},
  {0,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0},
  {0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
  {0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
};
//######################################################

// Channels
broadcast chan rescue[SURVIVORS_QTY], callFirstResponder[SURVIVORS_QTY], waitForSurvivor[FIRST_RESPONDERS_QTY], goToVictim[FIRST_RESPONDERS_QTY], helping[VICTIMS_QTY], save[VICTIMS_QTY];
pos_t survToFRVictimPos[FIRST_RESPONDERS_QTY];

// Manhattan distance since motion is on the 4 cardinal directions
int distance(pos_t pos1, pos_t pos2){
    int dist_x = pos1.x-pos2.x;
    int dist_y = pos1.y-pos2.y;

    if (pos1.x == pos_out_of_map.x || pos1.y == pos_out_of_map.y || pos2.x == pos_out_of_map.x || pos2.y == pos_out_of_map.y) {
        return INT16_MAX;
    }

    if(dist_x &lt; 0){
        dist_x = -dist_x;
    }
    if(dist_y &lt; 0){
        dist_y = -dist_y;
    }
    return dist_x+dist_y;
}

// Returns the ID of the closest entity
int utilGetClosest(int type, pos_t pos) {
    int closest = INT16_MAX;
    int closestDist = INT16_MAX;
    int temp;
    int k;
    if (type==SURVIVOR) {
        for(k=0; k&lt;entities[type]; k++) {
            temp = distance(pos, survivors[k]);
            if(temp &lt; closestDist &amp;&amp; !survivors_busy[k]){
                closest = k;
                closestDist = temp;      
            }
        }
    }
    if (type==VICTIM) {
        for(k=0; k&lt;entities[type]; k++) {
            temp = distance(pos, victims[k]);
            if(temp &lt; closestDist &amp;&amp; !victims_busy[k]){
                closest = k;
                closestDist = temp;      
            }
        }
    }
    if (type==FIRST_RESPONDER) {
        for(k=0; k&lt;entities[type]; k++) {
            temp = distance(pos, responders[k]);
            if(temp &lt; closestDist &amp;&amp; !responders_busy[k]){
                closest = k;
                closestDist = temp;      
            }
        }
    }
    if (type==DRONE) {
        for(k=0; k&lt;entities[type]; k++) {
            temp = distance(pos, drones[k]);
            if(temp &lt; closestDist){
                closest = k;
                closestDist = temp;      
            }
        }
    }
    return closest;
}

// Returns the pos_t of the closest entity
pos_t utilGetClosestPos(int type, pos_t pos) {
    int closestId = utilGetClosest(type, pos);
    if (closestId == INT16_MAX) {
        return pos_out_of_map;
    }
    
    if (type==SURVIVOR) {
        return survivors[closestId];
    }
    if (type==VICTIM) {
        return victims[closestId];
    }
    if (type==FIRST_RESPONDER) {
        return responders[closestId];
    }
    return drones[closestId];
}

pos_delta_t randomShift() {
    double choice = random(4);
    pos_delta_t toRet;
    if (choice &lt; 1) {
        toRet.x = 1;
        toRet.y = 0;
    } else if (choice &lt; 2) {
        toRet.x = -1;
        toRet.y = 0;
    } else if (choice &lt; 3) {
        toRet.x = 0;
        toRet.y = 1;
    } else if (choice &gt;= 3) {
        toRet.x = 0;
        toRet.y = -1;
    }
    return toRet;
}

bool isOccupied(pos_t p) {
    int i;
    for (i = 0; i &lt; SURVIVORS_QTY; i++) {
        if (survivors[i].x == p.x &amp;&amp; survivors[i].y == p.y) {
            return true;
        }
    }
    for (i = 0; i &lt; FIRST_RESPONDERS_QTY; i++) {
        if (responders[i].x == p.x &amp;&amp; responders[i].y == p.y) {
            return true;
        }
    }
    for (i = 0; i &lt; VICTIMS_QTY; i++) {
        if (victims[i].x == p.x &amp;&amp; victims[i].y == p.y) {
            return true;
        }
    }
    return false;
}

bool tileIsNearSomething(pos_t p, int type) {
    if (p.x-1 &gt; 0 &amp;&amp; map[p.x-1][p.y] == type) {
        return true;
    }
    if (p.x+1 &lt; N &amp;&amp; map[p.x+1][p.y] == type) {
        return true;
    }
    if (p.y-1 &gt; 0 &amp;&amp; map[p.x][p.y-1] == type) {
        return true;
    }
    if (p.y+1 &lt; M &amp;&amp; map[p.x][p.y+1] == type) {
        return true;
    }
    return false;
}

bool positionInvalid(int[-1,N+1] x, int[-1,M+1] y) {
    return x &lt; 0 || y &lt; 0 || x &gt;= N || y &gt;= M;
}</declaration>
	<template>
		<name x="5" y="5">Responder</name>
		<parameter>const id_f_t id</parameter>
		<declaration>// Place local declarations here.
clock t_resp;
pos_t victimPos;

void move() {    
    pos_t oldPos = responders[id];
    pos_t newPos;
    pos_delta_t posDelta;
    do {
        do {
            posDelta = randomShift();
        } while(positionInvalid(oldPos.x+posDelta.x, oldPos.y+posDelta.y));
        newPos.x = oldPos.x + posDelta.x;
        newPos.y = oldPos.y + posDelta.y;
    } while (map[newPos.x][newPos.y]==FIRE || isOccupied(newPos));

    responders[id] = newPos;
    t_resp = 0;
}

// Returns the ID of the closest entity, using the util function
int getClosest(int type) {
    return utilGetClosest(type, responders[id]);
}

// Returns the pos_t of the closest entity, using the util function
pos_t getClosestPos(int type) {
    return utilGetClosestPos(type, responders[id]);
}

void helpBeginningFar() {
    responders_busy[id] = true;
    victimPos = survToFRVictimPos[id];
    t_resp = 0;
}
void helpBeginningNear() {
    responders_busy[id] = true;
    victimPos = getClosestPos(VICTIM);
    t_resp = 0;
}

void doneHelping(){
    responders[id] = victimPos;
    t_resp = 0;
    responders_busy[id] = false;
}

</declaration>
		<location id="id0" x="-1105" y="-552">
			<name x="-1088" y="-552">Deciding</name>
			<committed/>
		</location>
		<location id="id1" x="-773" y="-841">
			<name x="-748" y="-867">Helping</name>
			<label kind="invariant" x="-748" y="-850">t_resp &lt;= T_fr</label>
		</location>
		<location id="id2" x="-773" y="-331">
			<name x="-807" y="-306">Reaching</name>
			<label kind="invariant" x="-986" y="-374">t_resp &lt;= distance(responders[id], victimPos)</label>
		</location>
		<location id="id3" x="-1513" y="-552">
			<name x="-1581" y="-569">Moving</name>
			<label kind="invariant" x="-1624" y="-552">t_resp &lt;= 1</label>
		</location>
		<location id="id4" x="-1105" y="-331">
			<name x="-1181" y="-306">Waiting_for_survivor</name>
		</location>
		<init ref="id0"/>
		<transition id="id5">
			<source ref="id0"/>
			<target ref="id4"/>
			<label kind="synchronisation" x="-1096" y="-467">waitForSurvivor[id]?</label>
			<label kind="assignment" x="-1088" y="-442">helpBeginningFar()</label>
		</transition>
		<transition id="id6">
			<source ref="id4"/>
			<target ref="id2"/>
			<label kind="synchronisation" x="-1003" y="-323">goToVictim[id]?</label>
			<label kind="assignment" x="-986" y="-297">t_resp = 0</label>
		</transition>
		<transition id="id7">
			<source ref="id3"/>
			<target ref="id4"/>
			<label kind="synchronisation" x="-1428" y="-382">waitForSurvivor[id]?</label>
			<label kind="assignment" x="-1419" y="-357">helpBeginningFar()</label>
			<nail x="-1513" y="-331"/>
		</transition>
		<transition id="id8">
			<source ref="id0"/>
			<target ref="id1"/>
			<label kind="guard" x="-1317" y="-918">distance(responders[id], getClosestPos(VICTIM)) &lt;= 1</label>
			<label kind="synchronisation" x="-1215" y="-867">helping[getClosest(VICTIM)]!</label>
			<label kind="assignment" x="-1173" y="-892">helpBeginningNear()</label>
			<nail x="-1105" y="-841"/>
		</transition>
		<transition id="id9">
			<source ref="id0"/>
			<target ref="id3"/>
			<label kind="guard" x="-1496" y="-603">distance(responders[id], getClosestPos(VICTIM)) &gt; 1</label>
			<label kind="assignment" x="-1360" y="-578">t_resp = 0</label>
		</transition>
		<transition id="id10">
			<source ref="id2"/>
			<target ref="id1"/>
			<label kind="guard" x="-986" y="-629">t_resp &gt;= distance(responders[id], victimPos)</label>
			<label kind="assignment" x="-765" y="-603">t_resp = 0</label>
		</transition>
		<transition id="id11">
			<source ref="id3"/>
			<target ref="id0"/>
			<label kind="guard" x="-1292" y="-518">t_resp &gt;= 1</label>
			<label kind="assignment" x="-1275" y="-493">move()</label>
			<nail x="-1326" y="-518"/>
		</transition>
		<transition id="id12">
			<source ref="id1"/>
			<target ref="id0"/>
			<label kind="guard" x="-1037" y="-739">t_resp &gt;= T_fr</label>
			<label kind="assignment" x="-1045" y="-714">doneHelping()</label>
		</transition>
	</template>
	<template>
		<name>Victim</name>
		<parameter>const id_v_t id</parameter>
		<declaration>void exitMap() {
    victims[id] = pos_out_of_map;
}

void setBusy() {
    victims_busy[id] = true;
}</declaration>
		<location id="id13" x="-544" y="-8">
			<name x="-569" y="-42">In_need</name>
		</location>
		<location id="id14" x="68" y="-8">
			<name x="58" y="-42">Safe</name>
		</location>
		<location id="id15" x="-246" y="-8">
			<name x="-289" y="-42">Being_helped</name>
		</location>
		<init ref="id13"/>
		<transition id="id16">
			<source ref="id13"/>
			<target ref="id15"/>
			<label kind="synchronisation" x="-450" y="-34">helping[id]?</label>
			<label kind="assignment" x="-442" y="-59">setBusy()</label>
		</transition>
		<transition id="id17">
			<source ref="id15"/>
			<target ref="id14"/>
			<label kind="synchronisation" x="-119" y="-34">save[id]?</label>
			<label kind="assignment" x="-119" y="-59">exitMap()</label>
		</transition>
	</template>
	<template>
		<name>Drone</name>
		<parameter>const id_d_t id</parameter>
		<declaration>// Place local declarations here.

clock t; 
pos_delta_t dir = {-1, -1};

void patrol() {
    int min_x = bounds[id].min_x;
    int max_x = bounds[id].max_x;
    int min_y = bounds[id].min_y;
    int max_y = bounds[id].max_y;
    if ((drones[id].x + dir.x &lt; min_x || drones[id].x + dir.x &gt; max_x) &amp;&amp; //hit both bounds
       (drones[id].y + dir.y &lt; min_y || drones[id].y + dir.y &gt; max_y)) {  //flip directions and restart
        dir.x = -dir.x;
        dir.y = -dir.y;
        if(drones[id].x + dir.x &gt; min_x &amp;&amp; drones[id].x + dir.x &lt; max_x){ //if can move x do it
            drones[id].x += dir.x;
        }
        //else stand still
    }
    else if (drones[id].x + dir.x &gt; min_x &amp;&amp; drones[id].x + dir.x &lt; max_x) { //if in bound move along x
        drones[id].x += dir.x;
    }
    else { // move y until new track
        drones[id].y += dir.y;
        if ((drones[id].y - min_y - Nv) % (2 * Nv + 1) == 0) { //on the last y-move flip x direction
            dir.x = -dir.x;
        }
    }
}

// Returns the ID of the closest entity, using the util function
int getClosest(int type) {
    return utilGetClosest(type, drones[id]);
}

// Returns the pos_t of the closest entity, using the util function
pos_t getClosestPos(int type) {
    return utilGetClosestPos(type, drones[id]);
}

bool survivorNear() {
    if ( distance(drones[id], getClosestPos(SURVIVOR)) &gt; Nv || distance(drones[id], getClosestPos(VICTIM)) &gt; Nv  ) {
        return false;
    }
    return true;
}

bool survivorWillHelp() {
    if ( distance(getClosestPos(SURVIVOR), getClosestPos(VICTIM)) &lt; distance(getClosestPos(SURVIVOR), getClosestPos(FIRST_RESPONDER)) + distance(getClosestPos(FIRST_RESPONDER), getClosestPos(VICTIM)) )
        return true;
    return false;
}

</declaration>
		<location id="id18" x="-374" y="-34">
			<name x="-408" y="-76">Deciding</name>
			<committed/>
		</location>
		<location id="id19" x="-59" y="-34">
			<name x="-85" y="-76">Moving</name>
			<label kind="invariant" x="-76" y="-102">t&lt;=1</label>
		</location>
		<location id="id20" x="-59" y="314">
			<name x="-110" y="348">Communicating</name>
			<committed/>
		</location>
		<location id="id21" x="348" y="-34">
			<committed/>
		</location>
		<init ref="id18"/>
		<transition id="id22">
			<source ref="id21"/>
			<target ref="id19"/>
			<label kind="synchronisation" x="0" y="-76">waitForSurvivor[getClosest(FIRST_RESPONDER)]!</label>
		</transition>
		<transition id="id23">
			<source ref="id20"/>
			<target ref="id19"/>
			<label kind="guard" x="-51" y="59">survivorWillHelp()</label>
			<label kind="synchronisation" x="-51" y="93">rescue[getClosest(SURVIVOR)]!</label>
		</transition>
		<transition id="id24">
			<source ref="id20"/>
			<target ref="id21"/>
			<label kind="guard" x="357" y="111">!survivorWillHelp()</label>
			<label kind="synchronisation" x="357" y="136">callFirstResponder[getClosest(SURVIVOR)]!</label>
			<nail x="348" y="306"/>
		</transition>
		<transition id="id25">
			<source ref="id18"/>
			<target ref="id20"/>
			<label kind="guard" x="-510" y="161">survivorNear()</label>
			<nail x="-374" y="314"/>
		</transition>
		<transition id="id26">
			<source ref="id19"/>
			<target ref="id18"/>
			<label kind="guard" x="-238" y="8">t&gt;=1</label>
			<label kind="assignment" x="-238" y="34">t=0</label>
			<nail x="-221" y="0"/>
		</transition>
		<transition id="id27">
			<source ref="id18"/>
			<target ref="id19"/>
			<label kind="guard" x="-272" y="-110">!survivorNear()</label>
			<label kind="assignment" x="-246" y="-85">patrol()</label>
			<nail x="-221" y="-59"/>
		</transition>
	</template>
	<template>
		<name x="5" y="5">Survivor</name>
		<parameter>const id_s_t id</parameter>
		<declaration>// Place local declarations here.
clock t;
int victim;
int responder;
pos_t victimPos;
pos_t responderPos;

void move() {    
    pos_t oldPos = survivors[id];
    pos_t newPos;
    pos_delta_t posDelta;
    do {
        do {
            posDelta = randomShift();
        } while(positionInvalid(oldPos.x+posDelta.x, oldPos.y+posDelta.y));
        newPos.x = oldPos.x + posDelta.x;
        newPos.y = oldPos.y + posDelta.y;
    } while (tileIsNearSomething(newPos, FIRE) || isOccupied(newPos));

    survivors[id] = newPos;
    t = 0;
}

// Returns the ID of the closest entity, using the util function
int getClosest(int type) {
    return utilGetClosest(type, survivors[id]);
}

// Returns the pos_t of the closest entity, using the util function
pos_t getClosestPos(int type) {
    return utilGetClosestPos(type, survivors[id]);
}

bool nearExit() {
    pos_t pos = survivors[id];
    return tileIsNearSomething(pos, EXIT);
}

void doneReachingFR() {
    survivors[id] = getClosestPos(FIRST_RESPONDER);
    t = 0;
}
void doneReachingVictim() {
    survivors[id]=getClosestPos(VICTIM);
    t = 0;
}
void doneReachingAlone() {
    survivors[id]=getClosestPos(VICTIM);
    t = 0;
}
void exitMap() {
    survivors[id] = pos_out_of_map;
}

void helpBeginning() {
    survivors_busy[id] = true;
    victim = getClosest(VICTIM);
    responder = getClosest(FIRST_RESPONDER);
    victimPos = victims[victim];
    responderPos = responders[responder];
}

void helpBeginningWithFR(){
    helpBeginning();
    survToFRVictimPos[responder] = victimPos;
}</declaration>
		<location id="id28" x="-162" y="442">
			<name x="-195" y="399">Deciding</name>
			<committed/>
		</location>
		<location id="id29" x="408" y="442">
			<name x="433" y="434">Moving</name>
			<label kind="invariant" x="441" y="459">t&lt;=1</label>
		</location>
		<location id="id30" x="977" y="119">
			<name x="960" y="144">Safe</name>
		</location>
		<location id="id31" x="646" y="119">
			<name x="620" y="85">Helping</name>
			<label kind="invariant" x="612" y="59">t &lt;= T_zr</label>
		</location>
		<location id="id32" x="170" y="119">
			<name x="109" y="85">Reaching_alone</name>
			<label kind="invariant" x="25" y="59">t &lt;= distance(survivors[id], victimPos)</label>
		</location>
		<location id="id33" x="-170" y="-76">
			<name x="-212" y="-110">Reaching_FR</name>
			<label kind="invariant" x="-314" y="-136">t &lt;= distance(survivors[id], responderPos)</label>
		</location>
		<location id="id34" x="977" y="-76">
			<name x="918" y="-110">Helping_with_FR</name>
			<label kind="invariant" x="943" y="-136">t &lt;= T_fr</label>
		</location>
		<location id="id35" x="408" y="-76">
			<name x="349" y="-110">Reaching_victim</name>
			<label kind="invariant" x="246" y="-136">t &lt;= distance(survivors[id], victimPos)</label>
		</location>
		<location id="id36" x="289" y="280">
			<committed/>
		</location>
		<location id="id37" x="-170" y="204">
			<committed/>
		</location>
		<init ref="id29"/>
		<transition id="id38">
			<source ref="id37"/>
			<target ref="id33"/>
			<label kind="synchronisation" x="-161" y="42">helping[victim]!</label>
			<label kind="assignment" x="-119" y="68">t = 0</label>
		</transition>
		<transition id="id39">
			<source ref="id36"/>
			<target ref="id32"/>
			<label kind="synchronisation" x="102" y="204">helping[victim]!</label>
			<label kind="assignment" x="153" y="229">t=0</label>
		</transition>
		<transition id="id40">
			<source ref="id35"/>
			<target ref="id34"/>
			<label kind="guard" x="535" y="-68">t &gt;= distance(survivors[id], victimPos)</label>
			<label kind="assignment" x="612" y="-42">doneReachingVictim()</label>
		</transition>
		<transition id="id41">
			<source ref="id33"/>
			<target ref="id35"/>
			<label kind="guard" x="-59" y="-68">t &gt;= distance(survivors[id], responderPos)</label>
			<label kind="synchronisation" x="34" y="-17">goToVictim[victim]!</label>
			<label kind="assignment" x="42" y="-42">doneReachingFR()</label>
			<nail x="391" y="-76"/>
		</transition>
		<transition id="id42">
			<source ref="id34"/>
			<target ref="id30"/>
			<label kind="guard" x="986" y="0">t &gt;= T_fr</label>
			<label kind="synchronisation" x="986" y="25">save[victim]!</label>
		</transition>
		<transition id="id43">
			<source ref="id29"/>
			<target ref="id37"/>
			<label kind="synchronisation" x="-144" y="280">callFirstResponder[id]?</label>
			<label kind="assignment" x="-127" y="306">helpBeginningWithFR()</label>
		</transition>
		<transition id="id44">
			<source ref="id32"/>
			<target ref="id31"/>
			<label kind="guard" x="246" y="136">t &gt;= distance(survivors[id], victimPos)</label>
			<label kind="assignment" x="323" y="161">doneReachingAlone()</label>
		</transition>
		<transition id="id45">
			<source ref="id29"/>
			<target ref="id36"/>
			<label kind="synchronisation" x="340" y="323">rescue[id]?</label>
			<label kind="assignment" x="348" y="348">helpBeginning()</label>
		</transition>
		<transition id="id46">
			<source ref="id31"/>
			<target ref="id30"/>
			<label kind="guard" x="756" y="127">t &gt;= T_zr</label>
			<label kind="synchronisation" x="739" y="178">save[victim]!</label>
			<label kind="assignment" x="756" y="153">exitMap()</label>
		</transition>
		<transition id="id47">
			<source ref="id29"/>
			<target ref="id28"/>
			<label kind="guard" x="25" y="450">t&gt;=1 &amp;&amp; !nearExit()</label>
			<label kind="assignment" x="93" y="476">t=0</label>
		</transition>
		<transition id="id48">
			<source ref="id29"/>
			<target ref="id30"/>
			<label kind="guard" x="671" y="306">nearExit()</label>
		</transition>
		<transition id="id49">
			<source ref="id28"/>
			<target ref="id29"/>
			<label kind="assignment" x="85" y="382">move()</label>
			<nail x="110" y="408"/>
		</transition>
	</template>
	<system>/*################# System declaration #################
THIS FILE IS AUTOGENERATED */

// Processes init
drone0 = Drone(0);
drone1 = Drone(1);
drone2 = Drone(2);
drone3 = Drone(3);

resp0 = Responder(0);
resp1 = Responder(1);
resp2 = Responder(2);

surv0 = Survivor(0);
surv1 = Survivor(1);
surv2 = Survivor(2);
surv3 = Survivor(3);
surv4 = Survivor(4);

vict0 = Victim(0);
vict1 = Victim(1);
vict2 = Victim(2);

// System definition
system drone0, drone1, drone2, drone3, resp0, resp1, resp2, surv0, surv1, surv2, surv3, surv4, vict0, vict1, vict2;</system>
	<queries>
		<query>
			<formula/>
			<comment/>
		</query>
	</queries>
</nta>
